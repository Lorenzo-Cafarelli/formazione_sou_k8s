# --- CONFIGURAZIONE DIPENDENZA NGINX ---
# Questo blocco configura il chart ufficiale che installeremo come dipendenza
ingress-nginx:
  enabled: true
  controller:
    service:
      type: LoadBalancer # Usa LoadBalancer per simulare un IP esterno (o NodePort se preferisci)
      # Se sei su Docker Desktop/Minikube tunnel, questo ti darà un IP (spesso 127.0.0.1)
    admissionWebhooks:
      enabled: false # Disabilitiamo i webhook per evitare timeout in fase di installazione locale

# --- CONFIGURAZIONE TUA APPLICAZIONE ---

replicaCount: 1

image:
  repository: lorenzocafarelli/flask-app-example
  pullPolicy: Always
  tag: "latest"

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  automount: true
  annotations: {}
  name: "custom-flask"

podAnnotations: {}
podLabels: {}

podSecurityContext: {}

securityContext: {}

# Configurazione del Servizio Flask
service:
  type: ClusterIP  # Cambiato da NodePort a ClusterIP (best practice con Ingress)
  port: 5000       # La porta interna su cui ascolta la tua app Flask
  # Nota: Non serve più definire nodePort qui

# Configurazione dell'Ingress
ingress:
  enabled: true
  className: "nginx" # Importante: definisce che deve essere gestito dal controller Nginx
  annotations:
    # Annotazioni utili. Questa serve se la tua app si aspetta traffico sulla root
    # nginx.ingress.kubernetes.io/rewrite-target: /
  hosts:
    - host: formazionesou.local
      paths:
        - path: /
          pathType: Prefix # 'Prefix' è generalmente meglio di 'ImplementationSpecific' per Nginx
  tls: []

resources:
  limits:
    cpu: 100m
    memory: 128Mi
  requests:
    cpu: 100m
    memory: 128Mi

livenessProbe:
  httpGet: 
    path: /
    port: 5000
readinessProbe:
  httpGet:
    path: /
    port: 5000

autoscaling:
  enabled: true
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80

volumes: []
volumeMounts: []
nodeSelector: {}
tolerations: []
affinity: {}