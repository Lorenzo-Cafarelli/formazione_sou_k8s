pipeline {
    agent {
        // Esegue la pipeline sul nodo Slave che abbiamo configurato
        label 'ContainerS' 
    }
    
    environment {
        // ID delle credenziali salvate su Jenkins (Username/Password per DockerHub)
        DOCKER_CREDENTIAL_ID = 'password_docker' 
        
        // Sostituisci con il TUO username di DockerHub
        DOCKER_IMAGE_NAME = 'lorenzocafarelli/flask-app-example' 
        
        // Registry URL
        DOCKER_REGISTRY = 'https://index.docker.io/v1/'
    }

    stages {
        stage('Checkout') {
            steps {
                // Scarica il codice dal repository
                checkout scm
            }
        }

        stage('Calculate Tag') {
            steps {
                script {
                    // Recupera l'hash breve del commit corrente (es. a1b2c3d)
                    def gitCommit = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    
                    // Recupera il nome del branch corrente
                    def branch = env.BRANCH_NAME
                    
                    // Logica richiesta dall'esercizio:
                    if (env.TAG_NAME) {
                        // CASO 1: Se è un TAG git (es. v1.0)
                        env.IMAGE_TAG = env.TAG_NAME
                        echo "Building from Git Tag: ${env.IMAGE_TAG}"
                        
                    } else if (branch == 'main' || branch == 'master') {
                        // CASO 2: Se è il branch master/main -> latest
                        env.IMAGE_TAG = 'latest'
                        echo "Building from Main/Master branch: latest"
                        
                    } else if (branch == 'develop') {
                        // CASO 3: Se è develop -> develop-SHA
                        env.IMAGE_TAG = "develop-${gitCommit}"
                        echo "Building from Develop branch: ${env.IMAGE_TAG}"
                        
                    } else {
                        // Caso di fallback (es. feature branch)
                        env.IMAGE_TAG = "feat-${gitCommit}"
                        echo "Building generic branch: ${env.IMAGE_TAG}"
                    }
                }
            }
        }

        stage('Build & Push') {
            steps {
                script {
                    // Login al registry usando le credenziali salvate in Jenkins
                    docker.withRegistry(env.DOCKER_REGISTRY, env.DOCKER_CREDENTIAL_ID) {
                        
                        // Costruisce l'immagine: nome + tag
                        def customImage = docker.build("${env.DOCKER_IMAGE_NAME}:${env.IMAGE_TAG}")
                        
                        // Effettua il push su DockerHub
                        customImage.push()
                        
                        // Opzionale: se è master, spesso si pusha ANCHE il tag specifico del commit oltre a latest
                        if (env.IMAGE_TAG == 'latest') {
                            def gitCommit = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                            customImage.push(gitCommit)
                        }
                    }
                }
            }
        }
    }
}